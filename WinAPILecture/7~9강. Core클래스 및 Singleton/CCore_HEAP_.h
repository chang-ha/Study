#pragma once
// 정적멤버를 힙영역에 올려놓고 주소값만 데이터영역에 올리는 방법

// 싱글톤 패턴
// 객체의 생성을 1개로 제한함
// 어디서든 쉽게 접근 가능해야함
class CCore_HEAP_
{
private:
	static CCore_HEAP_* g_pInst; // 힙영역을 가리키는 주소값이 데이터영역에 있음
public:
	// static이 붙은 함수는 객체가 없어도 호출할 수 있음 (객체있어도 가능은 함 << 별 의미 없음)
	// 객체없이 호출할 수 있는 이유
	// 1. this가 없음 (멤버에 접근을 못함)
	// 2. 정적 멤버(static 멤버)는 유일하게 접근 가능한 멤버
	//   * 정적변수선언
	//		1) 함수안에   (데이터영역 사용) << 함수안에 선언되더라도 함수의 호출과 종료에 정적변수의 할당 해제 유무에 아무 관련 없음 << 해당 함수에서만 접근 가능
	//		2) 파일안에   (데이터영역 사용) << 해당 파일안에서만 접근 가능 << 여러 파일에 정적 변수선언 되어도 이름 중복이 적용되지 않음
	//		3) 클래스안에 (데이터영역 사용) << 클래스 객체를 아무리 만들어도 클래스 안에 포함되어 있는게 아님(size에 포함 안됨) << 클래스 내부에서 접근 가능 
	//			<< 정적멤버변수는 무조건 클래스 밖에서 초기화를 한 번 해줘야함 (실체를 만들어 준다, 안만들어주면 LINK에러발생)
	static CCore_HEAP_* GetInstance()
	{
		// 최초 호출된 경우 (함수가 종료되어도 메모리가 살아있어야 하기 때문에 정적 변수로 만들어야함)
		// 정적변수의 초기화는 딱 한번만 발생함
		//static CCore* pCore = nullptr;
		if (nullptr == g_pInst)
		{
			g_pInst = new CCore_HEAP_; // 실체(객체)는 힙영역
		}
		// 두번 이상 호출된 경우
		// 아무것도 할 필요가 없음
		return g_pInst;
	}

	// 힙 영역을 할당했으니 삭제도 해줘야함
	// 해당 함수도 static함수로 만들어야함 (객체가 없기 때문에)
	// 근데 pCore를 알수가 없음 (지역변수)
	static void Release()
	{
		// 그럼 어떻게 할까??
		// 위의 함수를 호출하면 pCore주소값을 받을 수 있음
		//CCore* p = GetInstance();
		// 이렇게 짜면 문제가 발생함
		// 만약 GetInstance()로 pCore 하나의 변수를 만들어 사용하다가
		// Release()를 호출해서 지운후 다시 필요해서 다시 GetInstance()를 호출하면
		// 과연 새로 만들어질까?? (== pCore의 주소에 nullptr일까??) XXX
		// 이미 삭제된 곳의 주소를 들고있음 << 그래서 nullptr이 아니라고 판단하고 해당 주소값을 반환해줌
		// 그래서 함수안에서 정적 변수로 선언하지 않고 "클래스 내부에서 정적 멤버로 선언해줘야함"
		//delete p;
		if (nullptr != g_pInst)
		{
			delete g_pInst;
			g_pInst = nullptr;
		}
	}

protected:

private:
	// 생성자, 소멸자를 숨겨버리면 다른 곳에서 객체를 생성하지 못함
	CCore_HEAP_();
	~CCore_HEAP_();

};

