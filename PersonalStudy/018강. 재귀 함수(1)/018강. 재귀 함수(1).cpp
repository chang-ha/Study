#include <iostream>

int main()
{
	{
		// 재귀 함수 << 함수안에서 자기 자신을 호출하는 함수
		// 디버그창에서 로컬과 호출 스택이 정말 중요함!!
		// 함수들이 사용하는 메모리 영역 << 스택 영역
		// 함수가 끝나면 스택 영역에서 함수가 사라지는데
		// 그럼 main에 값을 전달하고 사라지나?? X
		// 레지스터 메모리라는 빠르게 접근해서 끌어다 쓸 수 있는 영역이 있슴
		// 함수 return값들을 cpu가 레지스터 메모리에 잠시 받아둠
		// 그리고 스택영역의 함수는 사라지고 main에서는 레지스터 메모리에서 끌어다 사용하는 것
		// 그럼 재귀함수는 어떻게 작동하는가??? (함수 내부에 자기 자신을 어떻게 다시 호출하는 가?)
		// 현재 쌓여있는 함수 위로 다시 새로운 함수가 쌓이는 것
		// Factorial함수위에 또 Factorial함수가 또 쌓이는 것 (Factorial함수위에 또 Factorial함수위에 또 Factorial... 이렇게 스택영역에 계속 쌓이는 것)
		// 그럼 어떤 문제가 생기나?? << 함수가 쌓여가기만 하고 종료는 되지 않음 
		// << 계속 쌓이다 보면 스택 메모리가 한계에 다다름 << 이런 에러를 "스택 오버플로우" 라고 함 (유명한 코드 포럼 사이트이름)
		// 그래서 "재귀함수는 탈출조건이 없으면 문제가 생김"
	}

	{
		// 재귀함수는 어떤 상황에 쓰이나??
		// 장점 : 가독성, 구현의 용이(숙련자 한정)
		// 단점 : 스택 오버플로우 발생여지, 성능이 많이 떨어짐(함수 호출비용 및 해제비용)
	}

}

